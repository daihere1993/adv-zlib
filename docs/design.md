# Goals

- Best performance for working with nested zip file
- Provide common APIs like `exists()`, `extract()`, `read()`
- Straem-based implementation for better performance
- Provide several hooks to customize cache behavior

# Strategy

One layer to provide very low-level APIs just like `yauzl`, and another layer to provide higher-level APIs like `exists()`, `extract()`, `read()`.

These low-level APIs should follow below principles:

- No global cache, every API should be independent and self-contained.

Special APIs for handling nested zip files:

- `ZipFile.createCentralDirectoryReader(zipEntry: ZipEntry, options)` to create a read stream for the central directory of a nested zip entry.
  =>

# AdvZlib

- How to use it in OAM-Kit?

```ts
const advZlib = new AdvZlib();
// Snapshot detector
async function detectRecursively(sourceFile: string, level: number, foundPaths: string[]): Promise<string[]> {
  if (level > MAX_LEVEL) return foundPaths;

  const isSnapshot = await advZlib.exists(`${sourceFile}/snapshot_file_list.txt`);
  if (isSnapshot) {
    foundPaths.push(sourceFile);
    return foundPaths;
  }
  const zipEntries = await advZlib.getEntries(sourceFile, (entry) => entry.fileName.endsWith('.zip'));
  for (const zipEntry of zipEntries) {
    await detectRecursively(`${path.dirname(sourceFile)}/${zipEntry.fileName}`, level + 1, foundPaths);
  }

  return foundPaths;
}

// 2. Snapshot analyzer
```

# APIs

## Low-level APIs

- lAdvZlib.open(path: string, options): Promise<ZipFile>
- lAdvZlib.createRawCDReader(inflatedStream: Readable, options): Readable
- lAdvZlib.createRawEntryReader(inflatedStream: Readable, options): Readable
- zipEntry.createReadStream(options): Promise<Readable>

### `llzlib.open(path: string, options): Promise<ZipFile>`

Open a zip file

### `llzlib.createRawCDReader(inflatedStream: Readable, options)`

Stream the central directory of a nested zip entry. User can use it to find all entries of the nested zip file with better performance.

Options:

- `maxCDSize`: The maximum size of the central directory.

Implementation:

1. Inflate the zipEntry then got a inflated stream
2. If `maxSize` >= the size of the central directory, we can capture the central directory directly with only one inflation
3. If `maxSize` < the size of the central directory
   3.1 If the captured buffer contains the EOCD, we can use the EOCD to find the central directory in second inflation
   3.2 If the captured buffer does not contain the EOCD, we need to expand the `maxSize` then try it again

### `llzlib.createRawEntryReader(inflatedStream: Readable, options)`

Stream the content of a zip entry that contains `EOCD + Corresponding CDFH + Local File Header + File Data`. User can use it to read/extract the content of a zip entry with better performance.

Options:

- `maxSize`: The maximum size of the entry.

Implementation:

1. If `maxSize` >= the size of the entry, we can capture the entry directly with only one inflation
2. If `maxSize` < the size of the entry
   2.1 If the captured buffer contains the EOCD, we can use the EOCD to find the entry in second inflation
   2.2 If the captured buffer does not contain the EOCD, we need to expand the `maxSize` then try it again

### `ZipEntry.createReadStream()`

Stream the content of a zip entry, if would be inflated if it has been deflated.

# llzlib

## TODOs

- [x] Support zip64 file and test to verify it
- [ ] Implement `llzlib.createRawCDReader()`
- [ ] Implement `llzlib.createRawEntryReader()`
- [ ] Add performance script to record the performance of different scenarios, we need to record the performance summary of each version of the library.
- [ ] Support `zipEntry.isEncrypted()`
- [ ] Create a well-designed test plan to verify the APIs
- [ ] Add a workflow to doc auto-generated by `typedoc`

## APIs

- llzlib.open(path: string): Promise<ZipFile>
- llzlib.createRawCDReader(inflatedStream: Readable, options: { maxCDSize: number }): Readable
- llzlib.createRawEntryReader(inflatedStream: Readable, options: { maxSize: number }): Readable
- zipEntry.nextEntry(): Promise<ZipEntry>
- zipEntry.createReadStream(): Promise<Readable>
- zipEntry.close(): void

## Usage

```ts
async function exists(path: string): Promise<boolean> {
  const zipFile = await llzlib.open('path/to/zipfile.zip');
  try {
    for (let i = 0; i < zipFile.entryCount; i++) {
      const entry = await zipFile.nextEntry();
      if (entry.fileName === path) {
        return true;
      }
    }
    return false;
  } catch (error) {
    return false;
  } finally {
    zipFile.close();
  }
}

async function extract(path: string, outputPath: string): Promise<void> {
  const zipFile = await llzlib.open(zipFilePath);
  try {
    for (let i = 0; i < zipFile.entryCount; i++) {
      const entry = await zipFile.nextEntry();
      if (entry.fileName === path) {
        const readStream = entry.createReadStream();
        await pipeline(readStream, fs.createWriteStream(outputPath));
        return;
      }
    }
  } catch (error) {
    throw new Error(`Entry ${path} not found`);
  } finally {
    zipFile.close();
  }
}
```
