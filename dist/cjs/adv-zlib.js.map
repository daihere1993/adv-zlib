{"version":3,"file":"adv-zlib.js","sourceRoot":"","sources":["../../src/adv-zlib.ts"],"names":[],"mappings":"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","sourcesContent":["import fs from \"node:fs\";\nimport fsPromises from \"node:fs/promises\";\nimport path from \"node:path\";\nimport { pipeline } from \"node:stream/promises\";\n// import findCacheDirectory from 'find-cache-dir';\nimport { CentralDir, CentralDirOptions } from \"./central-dir\";\nimport { ZipEntry } from \"./entry\";\nimport { Logger } from \"./types\";\nimport { ensureDirectoryExists } from \"./utils\";\n\nexport interface AdvZlibOptions {\n  logger?: Logger;\n  cacheDir?: string;\n  maxCacheSize?: number;\n  maxCacheEntries?: number;\n}\n\nexport class AdvZlib {\n  private logger!: Logger;\n  private maxCacheSize!: number;\n  private maxCacheEntries!: number;\n  private cacheDir!: string;\n  private cachedCentralDirs = new Map<string, CentralDir>();\n  private cachedExistenceInfos = new Map<string, boolean>();\n\n  constructor(opts?: AdvZlibOptions) {\n    this.logger = opts?.logger || console;\n    this.maxCacheSize = opts?.maxCacheSize || 50 * 1024 * 1024;\n    this.maxCacheEntries = opts?.maxCacheEntries || 10;\n    this.cacheDir = opts?.cacheDir || \"/tmp/adv-zlib\";\n    // this.cacheDir = opts?.cacheDir || findCacheDirectory({ name: 'adv-zlib' })!;\n\n    if (!fs.existsSync(this.cacheDir)) {\n      fs.mkdirSync(this.cacheDir, { recursive: true });\n    }\n  }\n\n  /**\n   * Get the list of entries in a ZIP file\n   * @param src The path of the zip file which can be:\n   * - Normal: `/a/b.zip`\n   * - Nested zip: `/a/b.zip/c.zip` or `/a/b.zip/c/d.zip`\n   * @param filterFn An optional callback function to filter entries\n   * @returns A promise that resolves to the list of filtered entries in the ZIP file.\n   */\n  public async getEntries(\n    src: string,\n    filterFn?: (entry: ZipEntry) => boolean\n  ): Promise<ZipEntry[]> {\n    this.logger.debug(`[AdvZlib] getEntries(): Getting entries for ${src}`);\n\n    if (!src) {\n      throw new Error(`[AdvZlib] getEntries(): src is required`);\n    }\n\n    if (!src.endsWith(\".zip\")) {\n      throw new Error(`[AdvZlib] getEntries(): ${src} is not a zip file`);\n    }\n\n    const centralDir = await this.getOrInitCentralDir(src);\n    if (!centralDir) {\n      this.logger.error(\n        `[AdvZlib] getEntries(): Failed to get central directory for ${src}`\n      );\n      return [];\n    }\n\n    return centralDir.entries.filter((entry) =>\n      filterFn ? filterFn(entry) : true\n    );\n  }\n\n  /**\n   * Check if a file exists in a ZIP file\n   * @param src The path of the zip file which can be:\n   * - Normal: `/a/b.zip/c.txt`\n   * - Folder: `/a/b.zip/c/`\n   * - Nested zip: `/a/b.zip/c.zip`\n   * @returns A promise that resolves to a boolean indicating whether the file exists in the ZIP file.\n   */\n  public async exists(src: string): Promise<boolean> {\n    this.logger.debug(`[AdvZlib] exists(): Checking if ${src} exists`);\n\n    if (!src) {\n      throw new Error(`[AdvZlib] exists(): ${src} is empty`);\n    }\n\n    if (this.cachedExistenceInfos.has(src)) {\n      return this.cachedExistenceInfos.get(src) ?? false;\n    }\n\n    if (await this.checkFileExists(src)) {\n      return true;\n    }\n\n    const centralDir = await this.getOrInitCentralDir(src);\n    if (src.endsWith(\".zip\")) {\n      return !!centralDir;\n    }\n\n    if (!centralDir) {\n      this.logger.error(\n        `[AdvZlib] exists(): Failed to get central directory for ${src}`\n      );\n      return false;\n    }\n\n    const entry = centralDir.entries.find((entry) => entry.fullPath === src);\n    const exsistence = !!entry;\n    this.cachedExistenceInfos.set(src, exsistence);\n\n    return exsistence;\n  }\n\n  /**\n   * Extracts selected entries from a ZIP file to a specified destination directory.\n   *\n   * @param src The source path to the ZIP file. Can represent a simple ZIP file or a nested path within a ZIP file.\n   * @param dest There several cases:\n   * - Case1: src is a zip(whatever nested or not) file, then `dest` must be a directory and this directory must exist.\n   * - Case2: src is a particular file within a zip file, then `dest` can either be a directory(where the content will be extracted)\n   *   or a file path(indicating where the extracted content will be saved).\n   * @param filterFn An optional filter function that determines which entries to extract.\n   *                   If provided, only entries for which the function returns `true` will be extracted.\n   * @returns A promise that resolves to an array of full paths of the extracted files.\n   * @throws Will throw an error if the `src` ZIP file does not exist or if the `dest` directory does not exist.\n   */\n  public async extract(\n    src: string,\n    dest: string,\n    filterFn?: (entry: ZipEntry) => boolean\n  ): Promise<string[]> {\n    this.logger.debug(`[AdvZlib] extract(): Extracting ${src} to ${dest}`);\n\n    if (!(await this.exists(src))) {\n      throw new Error(`[AdvZlib] extract(): ZIP file ${src} does not exist.`);\n    }\n\n    if (src.endsWith(\".zip\") && !(await this.checkFileExists(dest))) {\n      throw new Error(\n        `[AdvZlib] extract(): As ${src} is a zip file, ${dest} must be an existing directory.`\n      );\n    }\n\n    if (\n      !src.endsWith(\".zip\") &&\n      !(await this.checkFileExists(path.dirname(dest)))\n    ) {\n      throw new Error(\n        `[AdvZlib] extract(): ${path.dirname(dest)} does not exist.`\n      );\n    }\n\n    if (!src.endsWith(\".zip\") && filterFn) {\n      throw new Error(\n        `[AdvZlib] extract(): Filter function is only applicable for extracting a whole zip file.`\n      );\n    }\n\n    const centralDir = await this.getOrInitCentralDir(src);\n    if (!centralDir) {\n      throw new Error(\n        `[AdvZlib] extract(): Failed to get central directory for ${src}`\n      );\n    }\n\n    const extracted: string[] = [];\n    const entries = this.getRelatedEntries(src, centralDir.entries, filterFn);\n    await Promise.all(\n      entries.map(async (entry) => extracted.push(await entry.extract(dest)))\n    );\n\n    return extracted;\n  }\n\n  /**\n   * Reads the content of a specific file within a ZIP file.\n   *\n   * @param src - The path to the ZIP file or an entry within it. Accepted formats include:\n   *   - Type 1: `/a/b.zip` - Reads using a `filterFn` function to filter entries.\n   *   - Type 2: `/a/b.zip/c.txt` - Directly specifies a file entry to read, without a `filterFn`.\n   *   - Type 3: `/a/b.zip/c.zip` - Specifies a nested ZIP entry, read with a `filterFn` function.\n   *   - Type 4: `/a/b.zip/c.zip/d.txt` - Directly specifies a file entry within a nested ZIP, without a `filterFn`.\n   * @param filterFn - An optional filter function to select entries within the ZIP file.\n   *                   If provided, only entries for which the function returns `true` are considered.\n   * @returns A promise that resolves to a `Buffer` containing the file's contents, or an empty `Buffer`\n   *          if no matching entry is found or if multiple entries match.\n   * @throws Will throw an error if the `src` file does not exist.\n   */\n  async read(\n    src: string,\n    filterFn?: (entry: ZipEntry) => boolean\n  ): Promise<Buffer> {\n    this.logger.info(`[AdvZlib]read(): Reading content from ${src}`);\n\n    if (!(await this.exists(src))) {\n      throw new Error(\"read(): The source of the ZIP file is required.\");\n    }\n\n    const centralDir = await this.getOrInitCentralDir(src);\n    if (!centralDir) {\n      throw new Error(\n        `[AdvZlib] extract(): Failed to get central directory for ${src}`\n      );\n    }\n\n    const entries = this.getRelatedEntries(src, centralDir.entries, filterFn);\n    if (entries.length === 0) {\n      this.logger.error(`[AdvZlib]read(): No matching entries found in ${src}`);\n      return Buffer.alloc(0);\n    }\n\n    if (entries.length > 1) {\n      this.logger.error(\n        `[AdvZlib]read(): Multiple matching entries found in ${src}`\n      );\n      return Buffer.alloc(0);\n    }\n\n    return await entries[0].read();\n  }\n\n  public async cleanup() {\n    this.cachedCentralDirs.clear();\n    this.cachedExistenceInfos.clear();\n    await fsPromises.rm(this.cacheDir, { recursive: true, force: true });\n  }\n\n  /**\n   * Get the central directory of a ZIP file if it cached or initialize it if not\n   * @param src The path of the zip file which can be:\n   * - Normal: `/a/b.zip`\n   * - Nested zip: `/a/b.zip/c.zip` or `/a/b.zip/c/d.zip`\n   * @returns A promise that resolves to the central directory\n   */\n  private async getOrInitCentralDir(src: string): Promise<CentralDir | null> {\n    const deepestZipPath = this.getDeepestZipPath(src);\n    const cachedDir = this.cachedCentralDirs.get(deepestZipPath);\n    if (cachedDir) {\n      this.logger.info(\n        `[AdvZlib] _getOrInitCentralDir(): Using cached central directory for ${deepestZipPath}`\n      );\n      return cachedDir;\n    }\n\n    const zipPathSegs = this.splitZipPathIntoSegs(src).filter((seg) =>\n      seg.endsWith(\".zip\")\n    );\n\n    if (zipPathSegs.length === 0) {\n      this.logger.error(\n        `[AdvZlib] getOrInitCentralDir(): No ZIP segments found in path: ${src}`\n      );\n      return null;\n    }\n\n    let accumulatedPath = \"\";\n    let centralDir: CentralDir | null = null;\n\n    for (const seg of zipPathSegs) {\n      accumulatedPath = path.join(accumulatedPath, seg);\n\n      if (!centralDir) {\n        // Handle outermost ZIP file\n        const exists = await this.checkFileExists(accumulatedPath);\n        if (!exists) {\n          throw new Error(\n            `[AdvZlib] getOrInitCentralDir(): ZIP file ${accumulatedPath} does not exist.`\n          );\n        }\n\n        centralDir = await this._getOrInitCentralDir(accumulatedPath);\n      } else {\n        // Handle nested ZIP entries\n        const entry = this.findZipEntry(centralDir, accumulatedPath);\n        if (!entry) return null;\n\n        if (entry.size === 0) {\n          this.logger.warn(\n            `[AdvZlib] getOrInitCentralDir(): Entry ${seg} is empty in ${accumulatedPath}.`\n          );\n          return null;\n        }\n\n        const entryData = await this.handleEntryData(entry, accumulatedPath);\n        if (Buffer.isBuffer(entryData)) {\n          centralDir = await this._getOrInitCentralDir(\n            accumulatedPath,\n            entryData\n          );\n        } else if (typeof entryData === \"string\") {\n          // Large file cached to disk, no need to proceed further\n          centralDir = await this._getOrInitCentralDir(\n            accumulatedPath,\n            entryData\n          );\n        } else {\n          this.logger.warn(\n            `[AdvZlib] getOrInitCentralDir(): Entry ${seg} is empty in ${accumulatedPath}.`\n          );\n          return null;\n        }\n      }\n    }\n\n    return centralDir;\n  }\n\n  /**\n   * Initialize or retrieve a cached central directory\n   * @param src The path to the ZIP file\n   * @param dataSource Optional buffer data for nested ZIPs\n   * @returns A promise that resolves to the central directory\n   */\n  private async _getOrInitCentralDir(\n    src: string,\n    dataSource?: Buffer | string\n  ): Promise<CentralDir> {\n    const cachedDir = this.cachedCentralDirs.get(src);\n    if (cachedDir) {\n      this.logger.info(\n        `[AdvZlib] _getOrInitCentralDir(): Using cached central directory for ${src}`\n      );\n      return cachedDir;\n    }\n\n    const opts: CentralDirOptions = { logger: this.logger, dataSource };\n    const centralDir = new CentralDir(src, opts);\n    await centralDir.init();\n\n    if (this.cachedCentralDirs.size < this.maxCacheEntries) {\n      this.cachedCentralDirs.set(src, centralDir);\n    } else {\n      // Remove the oldest one\n      const oldest = this.cachedCentralDirs.keys().next().value;\n      if (oldest) {\n        this.cachedCentralDirs.delete(oldest);\n      }\n      // Append the new one\n      this.cachedCentralDirs.set(src, centralDir);\n    }\n\n    return centralDir;\n  }\n\n  private getRelatedEntries(\n    src: string,\n    entries: ZipEntry[],\n    filterFn?: (entry: ZipEntry) => boolean\n  ): ZipEntry[] {\n    const entryRelPath = this.getLastEntryRelPath(src);\n    return filterFn\n      ? entries.filter((entry) => filterFn(entry))\n      : entries.filter((entry) =>\n          entryRelPath ? entry.relPath === entryRelPath : true\n        );\n  }\n\n  /**\n   * Split a ZIP path into its ZIP segments\n   * E.g., '/a/b.zip/c.zip/d/e.zip/f.txt' to ['/a/b.zip', '/c.zip', '/d/e.zip', '/f.txt']\n   * @param src The source ZIP path\n   * @returns An array of path segments\n   */\n  private splitZipPathIntoSegs(src: string): string[] {\n    const normalizedPath = path.normalize(src);\n    const segments = normalizedPath.split(path.sep);\n    const result: string[] = [];\n\n    const finalPath = segments.reduce(\n      (accumulator, segment) => {\n        if (segment === \"\") return accumulator;\n        if (accumulator === \"\") return segment;\n\n        const newPath =\n          accumulator === path.sep\n            ? `${accumulator}${segment}`\n            : `${accumulator}${path.sep}${segment}`;\n\n        if (segment.endsWith(\".zip\")) {\n          result.push(newPath);\n          return path.sep;\n        }\n\n        return newPath;\n      },\n      src.startsWith(path.sep) ? path.sep : \"\"\n    );\n\n    if (finalPath && finalPath !== path.sep) {\n      result.push(finalPath);\n    }\n\n    return result;\n  }\n\n  /**\n   * Get the last entry relative path, e.g., '/a/b.zip/c/d.txt' to 'c/d.txt'\n   * @param src The source ZIP path\n   * @returns The last entry relative path\n   */\n  private getLastEntryRelPath(src: string, includeZip = false): string {\n    let lastEntryRelPath = this.splitZipPathIntoSegs(src).pop();\n\n    if (lastEntryRelPath?.endsWith(\".zip\")) {\n      lastEntryRelPath = includeZip ? lastEntryRelPath : \"\";\n    }\n\n    if (lastEntryRelPath?.startsWith(\"/\")) {\n      lastEntryRelPath = lastEntryRelPath.slice(1);\n    }\n\n    return lastEntryRelPath || \"\";\n  }\n\n  /**\n   * Get the deepest zip path, e.g., '/a/b.zip/c/d.zip/e.txt' to '/a/b.zip/c/d.zip'\n   * @param src The source ZIP path\n   * @returns The deepest zip path\n   */\n  private getDeepestZipPath(src: string): string {\n    if (src.endsWith(\".zip\")) {\n      return src;\n    }\n\n    const zipPathSegs = this.splitZipPathIntoSegs(src).filter((seg) =>\n      seg.endsWith(\".zip\")\n    );\n    return path.join(...zipPathSegs);\n  }\n\n  /**\n   * Check if a file exists asynchronously\n   * @param filePath The path to the file\n   * @returns A promise that resolves to true if exists, false otherwise\n   */\n  private async checkFileExists(filePath: string): Promise<boolean> {\n    try {\n      await fsPromises.access(filePath);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Find a ZIP entry within the central directory\n   * @param centralDir The central directory to search\n   * @param zipFilePath The current ZIP file path\n   * @returns The found entry or null\n   */\n  private findZipEntry(\n    centralDir: CentralDir,\n    zipFilePath: string\n  ): ZipEntry | null {\n    const lastEntryRelPath = this.getLastEntryRelPath(zipFilePath, true);\n    const entry = centralDir.entries.find(\n      (entry) => !entry.isDirectory && entry.relPath === lastEntryRelPath\n    );\n\n    if (!entry) {\n      this.logger.error(\n        `[AdvZlib] findZipEntry(): Entry ${lastEntryRelPath} does not exist in ${zipFilePath}.`\n      );\n      return null;\n    }\n\n    if (entry.size === 0) {\n      this.logger.warn(\n        `[AdvZlib] findZipEntry(): Entry ${lastEntryRelPath} is empty in ${zipFilePath}.`\n      );\n      return null;\n    }\n\n    return entry;\n  }\n\n  /**\n   * Handle reading and caching of a ZIP entry\n   * @param entry The ZIP entry to handle\n   * @param zipFilePath The current ZIP file path\n   * @returns The entry data buffer or null if cached to disk\n   */\n  private async handleEntryData(\n    entry: ZipEntry,\n    zipFilePath: string\n  ): Promise<Buffer | string | null> {\n    if (entry.size >= this.maxCacheSize) {\n      const segs = this.splitZipPathIntoSegs(zipFilePath);\n      segs[0] = path.basename(segs[0]);\n      const cacheFile = path.join(this.cacheDir, ...segs);\n\n      await ensureDirectoryExists(path.dirname(cacheFile));\n      const writeStream = fs.createWriteStream(cacheFile);\n      const readStream = await entry.createReadStream();\n\n      try {\n        await pipeline(readStream, writeStream);\n        this.logger.info(\n          `[AdvZlib] handleEntryData(): Cached large entry to ${cacheFile}`\n        );\n        entry.onCache(cacheFile);\n        return cacheFile;\n      } catch (err: any) {\n        this.logger.error(\n          `[AdvZlib] handleEntryData(): Failed to cache entry ${entry.relPath}: ${err.message}`\n        );\n        return null;\n      }\n    } else {\n      try {\n        const data = await entry.read();\n        if (data.length === 0) {\n          this.logger.warn(\n            `[AdvZlib] handleEntryData(): Entry ${entry.relPath} is empty.`\n          );\n          return null;\n        }\n        entry.onCache(data);\n        return data;\n      } catch (err: any) {\n        this.logger.error(\n          `[AdvZlib] handleEntryData(): Failed to read entry ${entry.relPath}: ${err.message}`\n        );\n        return null;\n      }\n    }\n  }\n}\n"]}